# Code Review - Exception API Consistency and Hierarchy

**Date:** 2025-11-09 02:40:34
**Reviewer:** Claude Code
**File:** `src/aclaf/parser/exceptions.py`
**Focus:** Exception hierarchy, API consistency, error messages, and documentation

## Summary

The parser exceptions module demonstrates a well-structured exception hierarchy with comprehensive documentation and consistent patterns. The code shows strong attention to detail with thorough docstrings, clear type annotations, and thoughtful error messaging. However, there are several inconsistencies in API design, error message formatting, and attribute handling that should be addressed to improve the overall quality and usability of the exception system.

**Overall Quality:** Good with notable areas for improvement

## Scope

- **Primary File:** `src/aclaf/parser/exceptions.py` (718 lines)
- **Supporting Files Reviewed:**
  - `src/aclaf/parser/_utils.py` (utility functions)
  - `src/aclaf/parser/types.py` (Arity type)
  - Parser and command modules (exception usage patterns)
- **Focus Areas:**
  - Exception hierarchy and inheritance
  - Constructor signature consistency
  - Error message formatting and user experience
  - Attribute design and documentation
  - Documentation completeness and accuracy

## Critical Issues (MUST FIX)

### 1. Inconsistent Parameter Naming Across Similar Exceptions

**Lines:** 135, 611, 533, 573

**Issue:** The exceptions use inconsistent parameter names for the same semantic concept:

- `UnknownOptionError.__init__(name, possible_names)` → stores as `all_names`
- `UnknownSubcommandError.__init__(name, possible_names)` → stores as `all_names`
- `AmbiguousOptionError.__init__(name, candidates)` → stores as `candidates`
- `AmbiguousSubcommandError.__init__(name, candidates)` → stores as `candidates`

**Problem:** The parameter name `possible_names` is stored in attribute `all_names`, creating confusion between the API surface (what callers pass) and the stored data (what error handlers read). This violates the principle of least surprise.

**Recommendation:**
```python
# Option 1: Align parameter and attribute names
def __init__(self, name: str, all_names: tuple[str, ...]) -> None:
    self.name: str = name
    self.all_names: tuple[str, ...] = all_names
    # ...

# Option 2: Make parameter name match attribute (keep as possible_names)
def __init__(self, name: str, possible_names: tuple[str, ...]) -> None:
    self.name: str = name
    self.possible_names: tuple[str, ...] = possible_names  # Changed from all_names
    # Update docstrings accordingly
```

**Impact:** This inconsistency makes the API confusing for users who need to catch and handle these exceptions programmatically. When they see `possible_names` in the signature but need to access `all_names` on the exception instance, it creates unnecessary cognitive load.

---

### 2. Inconsistent Error Message Formatting for Options

**Lines:** 138, 181-186, 228-233, 273-275, 315-321, 356-361, 409-414, 454-457, 495-498

**Issue:** The module uses three different approaches for formatting option names in error messages:

1. **No formatting** (uses name directly):
   - `UnknownOptionError`: `"Unknown option '{name}'."`
   - `MultiValueOptionEqualsError`: `"Option '{name}' accepts..."`
   - `InsufficientOptionValuesError`: `"Insufficient values provided for option '{name}'."`

2. **Uses `full_option_name()` for both user and canonical**:
   - `OptionCannotBeSpecifiedMultipleTimesError` (lines 181-186)
   - `OptionCannotBeCombinedError` (lines 228-233)
   - `OptionDoesNotAcceptValueError` (lines 273-275)
   - `FlagWithValueError` (lines 315-321)
   - `MissingOptionValueError` (lines 356-361)
   - `InvalidFlagValueError` (lines 409-414)

3. **Hardcoded `--` prefix**:
   - `AmbiguousOptionError` (line 537): `"Ambiguous option '--{name}'."`

**Example of the inconsistency:**
```python
# UnknownOptionError - no prefix added
message = f"Unknown option '{name}'."  # Line 138

# OptionCannotBeSpecifiedMultipleTimesError - adds prefix via full_option_name
message_name = full_option_name(name)  # Line 181
canonical_name = full_option_name(option_spec.name)
message = f"Option '{message_name}' ({canonical_name}) cannot be..."

# AmbiguousOptionError - hardcoded -- prefix
message = f"Ambiguous option '--{name}'."  # Line 537
```

**Problem:** This creates inconsistent user experience where some error messages show options as `verbose`, others as `--verbose`, and yet others distinguish between what the user typed (`-v`) and the canonical name (`--verbose`).

**Recommendation:** Standardize on a consistent approach:

```python
# Recommended: Always use full_option_name() for consistency
# Update UnknownOptionError, MultiValueOptionEqualsError, InsufficientOptionValuesError
def __init__(self, name: str, possible_names: tuple[str, ...]) -> None:
    self.name: str = name
    self.all_names: tuple[str, ...] = possible_names
    message_name = full_option_name(name)  # Add this
    message = f"Unknown option '{message_name}'."  # Update this
    super().__init__(message)

# For AmbiguousOptionError - remove hardcoded prefix
def __init__(self, name: str, candidates: list[str]) -> None:
    self.name: str = name
    self.candidates: list[str] = sorted(candidates)
    formatted_name = full_option_name(name)  # Add this
    message = f"Ambiguous option '{formatted_name}'."  # Remove hardcoded --
    super().__init__(message)
```

**Impact:** Users receive inconsistent error messages that make the tool appear less polished and can cause confusion about the correct syntax for options.

---

### 3. Missing Canonical Name Context in Some Option Exceptions

**Lines:** 138, 454-457, 495-498, 537

**Issue:** Several option-related exceptions that have access to `option_spec` don't show the canonical name in error messages, while others do. This is inconsistent:

**With canonical name (good):**
- `OptionCannotBeSpecifiedMultipleTimesError`: `"Option '-o' (--output) cannot be..."`
- `FlagWithValueError`: `"Flag option '-v' (--verbose) does not accept..."`

**Without canonical name (inconsistent):**
- `MultiValueOptionEqualsError`: `"Option 'files' accepts multiple values..."`
  - This exception only receives `name`, not `option_spec`, so it can't show canonical name
- `InsufficientOptionValuesError`: `"Insufficient values provided for option 'output'."`
  - This exception has `option_spec` but doesn't use it in the message!

**Code Analysis:**
```python
# Line 452-458: MultiValueOptionEqualsError
def __init__(self, name: str) -> None:
    self.name: str = name
    message = f"Option '{name}' accepts multiple values..."
    # No option_spec available - can't show canonical

# Line 492-499: InsufficientOptionValuesError
def __init__(self, name: str, option_spec: "OptionSpec") -> None:
    self.name: str = name
    self.option_spec: OptionSpec = option_spec
    message = f"Insufficient values provided for option '{name}'."
    # Has option_spec but doesn't use it in message!
```

**Recommendation:**

1. **Update `InsufficientOptionValuesError` to include canonical name** (line 495-498):
```python
def __init__(self, name: str, option_spec: "OptionSpec") -> None:
    self.name: str = name
    self.option_spec: OptionSpec = option_spec
    message_name = full_option_name(name)
    canonical_name = full_option_name(option_spec.name)
    message = (
        f"Insufficient values provided for option '{message_name}' ({canonical_name}). "
        f"Expected at least {option_spec.arity}."
    )
    super().__init__(message)
```

2. **Update `MultiValueOptionEqualsError` to accept `option_spec`** (lines 452-458):
```python
def __init__(self, name: str, option_spec: "OptionSpec") -> None:
    self.name: str = name
    self.option_spec: OptionSpec = option_spec
    message_name = full_option_name(name)
    canonical_name = full_option_name(option_spec.name)
    message = (
        f"Option '{message_name}' ({canonical_name}) accepts multiple values and "
        "cannot be specified using '=' syntax."
    )
    super().__init__(message)
```

**Impact:** When users make mistakes, they need clear feedback about what option caused the error. Showing both what they typed and the canonical form helps them understand the relationship between short and long forms. The current inconsistency makes some errors more helpful than others for no good reason.

---

### 4. Inconsistent Storage of `true_values` and `false_values` in InvalidFlagValueError

**Lines:** 397-415

**Issue:** The `InvalidFlagValueError` constructor accepts `true_values` and `false_values` parameters but doesn't store them as attributes. This is inconsistent with the documented "Attributes:" section in the docstring and prevents error handlers from accessing this information.

**Code:**
```python
def __init__(
    self,
    name: str,
    value: str,
    option_spec: "OptionSpec",
    true_values: frozenset[str],
    false_values: frozenset[str],
) -> None:
    self.name: str = name
    self.value: str = value
    self.option_spec: OptionSpec = option_spec
    # true_values and false_values are NOT stored!

    message_name = full_option_name(name)
    canonical_name = full_option_name(option_spec.name)
    message = (
        f"Invalid value '{value}' for option '{message_name}' ({canonical_name}). "
        f"Expected one of: {', '.join(sorted(true_values | false_values))}."
    )
    super().__init__(message)
```

**Docstring claims (lines 371-374):**
```python
    Attributes:
        name: The flag option name as provided by the user.
        value: The invalid value that was provided.
        option_spec: The option specification for the flag.
```

**Problem:** The docstring only documents `name`, `value`, and `option_spec`, but not `true_values` and `false_values`. However, these values are used in the error message, suggesting they might be useful for error handlers. The implementation doesn't store them, but perhaps it should.

**Recommendation:**

```python
def __init__(
    self,
    name: str,
    value: str,
    option_spec: "OptionSpec",
    true_values: frozenset[str],
    false_values: frozenset[str],
) -> None:
    self.name: str = name
    self.value: str = value
    self.option_spec: OptionSpec = option_spec
    self.true_values: frozenset[str] = true_values
    self.false_values: frozenset[str] = false_values

    message_name = full_option_name(name)
    canonical_name = full_option_name(option_spec.name)
    message = (
        f"Invalid value '{value}' for option '{message_name}' ({canonical_name}). "
        f"Expected one of: {', '.join(sorted(true_values | false_values))}."
    )
    super().__init__(message)
```

Update docstring (after line 374):
```python
    Attributes:
        name: The flag option name as provided by the user.
        value: The invalid value that was provided.
        option_spec: The option specification for the flag.
        true_values: The set of accepted truthy values.
        false_values: The set of accepted falsey values.
```

**Impact:** Error handlers that catch this exception might want to programmatically suggest valid values or implement recovery logic. Without access to `true_values` and `false_values`, they would need to duplicate this configuration or parse it from the error message.

## Important Suggestions (SHOULD FIX)

### 5. Inconsistent Attribute Type Declarations Between Similar Exceptions

**Lines:** 533-535, 573-575

**Issue:** `AmbiguousOptionError` and `AmbiguousSubcommandError` use `list[str]` for `candidates`, while `UnknownOptionError` and `UnknownSubcommandError` use `tuple[str, ...]` for `all_names`. Since these serve the same semantic purpose (collection of valid names), they should use the same type.

**Code:**
```python
# AmbiguousOptionError - uses list
def __init__(self, name: str, candidates: list[str]) -> None:
    self.name: str = name
    self.candidates: list[str] = sorted(candidates)

# UnknownOptionError - uses tuple
def __init__(self, name: str, possible_names: tuple[str, ...]) -> None:
    self.name: str = name
    self.all_names: tuple[str, ...] = possible_names
```

**Recommendation:** Use `tuple[str, ...]` consistently for immutable collections of names:

```python
# Update AmbiguousOptionError and AmbiguousSubcommandError
def __init__(self, name: str, candidates: list[str]) -> None:
    self.name: str = name
    self.candidates: tuple[str, ...] = tuple(sorted(candidates))
    message = (
        f"Ambiguous option '--{name}'. Possible matches: {', '.join(self.candidates)}."
    )
    super().__init__(message)
```

**Rationale:** Tuples are the appropriate choice for:
1. **Immutability:** The list of candidates shouldn't change after the exception is created
2. **Consistency:** All similar exceptions use the same type for name collections
3. **Hashability:** Tuples can be used in sets/dicts if needed for error analysis
4. **Semantic clarity:** Tuples signal "this is a fixed collection" vs lists which suggest mutability

**Impact:** Using lists suggests the collection might be modified, which isn't the intent. This creates minor API confusion and prevents using these exceptions in certain contexts (e.g., as dict keys).

---

### 6. `ArityMismatchError` Not Used and Poorly Integrated

**Lines:** 57-95

**Issue:** `ArityMismatchError` appears to be a general-purpose arity validation exception, but it's not actually used anywhere in the codebase. Instead, the parser uses more specific exceptions like `InsufficientOptionValuesError` and `InsufficientPositionalArgumentsError`.

**Analysis:**
- The exception exists and is well-documented
- The example in the docstring shows manual construction
- Grep analysis shows it's never raised by parser code
- It has a generic `name` parameter rather than distinguishing between options and positionals
- It doesn't follow the pattern of other exceptions (no `option_spec` or context)

**Evidence:**
```bash
# From grep analysis - ArityMismatchError is only in docstring example
src/aclaf/parser/exceptions.py:79:        ...     raise ArityMismatchError("output", expected=2, received=1)
```

**Recommendation:**

**Option A (Recommended):** Remove `ArityMismatchError` if it's not used:
- The specific exceptions (`InsufficientOptionValuesError`, `InsufficientPositionalArgumentsError`) provide better context
- Having an unused exception in the public API creates confusion
- If needed in the future, it can be added back

**Option B:** Use it as an internal base class:
```python
class ArityMismatchError(ParseError):
    """Base exception for arity-related errors."""
    def __init__(self, name: str, expected: int, received: int) -> None:
        self.name: str = name
        self.expected: int = expected
        self.received: int = received
        # Don't construct message in base class

class InsufficientOptionValuesError(ArityMismatchError):
    """Exception raised when option doesn't receive enough values."""
    def __init__(self, name: str, option_spec: "OptionSpec") -> None:
        # Calculate expected/received from option_spec
        super().__init__(name, expected=option_spec.arity.min, received=?)
        self.option_spec = option_spec
        # Construct specific message
```

**Option C:** Document it as a base class users can catch:
- Update docstring to explain it's a base class for arity errors
- Make `InsufficientOptionValuesError` and `InsufficientPositionalArgumentsError` inherit from it
- Update "When Raised" to say "Never raised directly, catch to handle all arity errors"

**Impact:** The current state is confusing because the exception exists in the public API but is never used. This wastes users' time when they discover it and wonder when to use it.

---

### 7. Inconsistent Quoting Style in Error Messages

**Lines:** Multiple throughout the file

**Issue:** Error messages use inconsistent quoting styles for values:

- Single quotes for option/subcommand names: `'verbose'`, `'--output'`
- Single quotes for values: `'true'`, `'file.txt'`
- No quotes for counts/numbers: `expected 2 argument(s)`
- Inconsistent formatting for lists: `'{', '}'.join(...)` vs `', '.join(...)`

**Examples:**
```python
# Good: Consistent single quotes
f"Unknown option '{name}'."
f"Invalid value '{value}' for option '{message_name}'..."

# Inconsistent: Mixed quote styles in UnknownSubcommandError
subcommand_list = "', '".join(sorted(possible_names))
message_parts.append(f"Available subcommands: '{subcommand_list}'.")
# Results in: "Available subcommands: 'commit', 'push', 'pull'."
# The outer quotes are redundant since join already adds quotes
```

**Analysis of line 629-630:**
```python
subcommand_list = "', '".join(sorted(possible_names))
message_parts.append(f"Available subcommands: '{subcommand_list}'.")
# This produces: "Available subcommands: 'commit', 'push', 'pull'."
# Should be: "Available subcommands: commit, push, pull"
# Or: "Available subcommands: 'commit', 'push', 'pull'"
```

**Recommendation:** Standardize quoting rules:

1. **For single items:** Use single quotes
   - `"Unknown option '{name}'"`
   - `"Invalid value '{value}'"`

2. **For lists:** Use consistent formatting without redundant quotes
```python
# Update UnknownSubcommandError (lines 628-630)
if possible_names:
    subcommand_list = ", ".join(sorted(possible_names))
    message_parts.append(f"Available subcommands: {subcommand_list}")
# Results in: "Available subcommands: commit, push, pull"
```

3. **For numbers:** No quotes
   - `expected {expected} argument(s)`

**Impact:** Inconsistent quoting creates a less polished user experience and can make error messages harder to parse programmatically.

---

### 8. Arity Display in Error Messages Should Be More User-Friendly

**Lines:** 495-498

**Issue:** `InsufficientOptionValuesError` displays arity using the repr format: `Expected at least Arity(min=2, max=3).`

**Code:**
```python
message = (
    f"Insufficient values provided for option '{name}'. "
    f"Expected at least {option_spec.arity}."
)
```

**Problem:** This exposes the internal `Arity` type to users. The message should be more natural:
- Current: `"Expected at least Arity(min=2, max=3)."`
- Better: `"Expected at least 2 value(s)."`
- Best: `"Expected 2-3 values."`

**Recommendation:**

```python
def __init__(self, name: str, option_spec: "OptionSpec") -> None:
    self.name: str = name
    self.option_spec: OptionSpec = option_spec

    # Format arity more naturally
    arity = option_spec.arity
    if arity.min == arity.max:
        arity_desc = f"{arity.min} value(s)"
    elif arity.max is None:
        arity_desc = f"at least {arity.min} value(s)"
    else:
        arity_desc = f"{arity.min}-{arity.max} values"

    message_name = full_option_name(name)
    canonical_name = full_option_name(option_spec.name)
    message = (
        f"Insufficient values provided for option '{message_name}' ({canonical_name}). "
        f"Expected {arity_desc}."
    )
    super().__init__(message)
```

**Impact:** Users should never see internal type representations in error messages. This makes the tool feel more professional and user-friendly.

---

### 9. Ambiguous Use of "Name" Terminology

**Lines:** 106, 329, 465, etc.

**Issue:** The term "name" is used ambiguously throughout:
- Sometimes means "what the user typed" (could be `-v`, `--verbose`, or `verb` as abbreviation)
- Sometimes means "canonical name" (the primary identifier like `verbose`)
- Docstrings say "as provided by the user" but don't clarify if this includes prefixes

**Examples:**
```python
# Line 106: UnknownOptionError
    Attributes:
        name: The unknown option name as provided by the user.
        # Does this mean "v", "-v", "--verbose", or "verbose"?

# Line 329: MissingOptionValueError
    Attributes:
        name: The option name as provided by the user.
        # Again, unclear if this includes dashes
```

**Problem:** When debugging or handling exceptions, it's unclear what format `name` will have. This makes it harder to:
- Match against known options
- Display helpful messages
- Implement error recovery

**Recommendation:** Clarify in docstrings and consider renaming:

```python
class UnknownOptionError(ParseError):
    """Exception raised when an unknown option is encountered.

    ...

    Attributes:
        name: The unknown option name as provided by the user, without
            prefix dashes (e.g., "v" for -v, "verbose" for --verbose).
        all_names: Tuple of all valid option names without prefixes,
            for generating suggestions or implementing error recovery.
```

Or use more explicit naming:
```python
def __init__(self, user_input: str, option_spec: "OptionSpec") -> None:
    self.user_input: str = user_input  # What user typed: "-v" or "--verbose"
    self.option_name: str = option_spec.name  # Canonical: "verbose"
    self.option_spec: OptionSpec = option_spec
```

**Impact:** Clearer naming reduces bugs in error handling code and makes the API easier to learn.

---

### 10. Missing `option_spec` Validation in Constructors

**Lines:** 177-187, 224-234, 269-276, 311-322, 352-362

**Issue:** Several exceptions accept an `option_spec` parameter but don't validate that it's not None or that it's the right type. If the parser has a bug and passes None, the error message construction could fail with an AttributeError.

**Current code has no validation:**
```python
def __init__(self, name: str, option_spec: "OptionSpec") -> None:
    self.name: str = name
    self.option_spec: OptionSpec = option_spec

    message_name = full_option_name(name)
    canonical_name = full_option_name(option_spec.name)  # Could fail if option_spec is None
    # ...
```

**Recommendation:** Add defensive validation:

```python
def __init__(self, name: str, option_spec: "OptionSpec") -> None:
    if option_spec is None:
        raise ValueError("option_spec cannot be None")

    self.name: str = name
    self.option_spec: OptionSpec = option_spec
    # ... rest of init
```

**Counterargument:** Since these are internal exceptions raised only by parser code, validation might be unnecessary overhead. However, adding assertions or type guards helps catch parser bugs during development.

**Impact:** Low priority, but could prevent confusing error messages if there's a bug in the parser that passes invalid data to exception constructors.

## Optional Improvements (NICE TO HAVE)

### 11. Consider Adding a Common Base Class for Option-Related Exceptions

**Observation:** Seven exceptions share the pattern `(name: str, option_spec: OptionSpec)`:
- `OptionCannotBeSpecifiedMultipleTimesError`
- `OptionCannotBeCombinedError`
- `OptionDoesNotAcceptValueError`
- `FlagWithValueError`
- `MissingOptionValueError`
- `InsufficientOptionValuesError`
- `InvalidFlagValueError` (has additional parameters)

**Suggestion:** Consider creating a base class:

```python
class OptionError(ParseError):
    """Base class for option-related parsing errors.

    Attributes:
        name: The option name as provided by the user.
        option_spec: The option specification for reference.
    """

    def __init__(self, name: str, option_spec: "OptionSpec") -> None:
        self.name: str = name
        self.option_spec: OptionSpec = option_spec
        # Subclasses will construct their own messages
        super().__init__("")

class OptionCannotBeSpecifiedMultipleTimesError(OptionError):
    def __init__(self, name: str, option_spec: "OptionSpec") -> None:
        super().__init__(name, option_spec)
        message_name = full_option_name(name)
        canonical_name = full_option_name(option_spec.name)
        message = (
            f"Option '{message_name}' ({canonical_name}) cannot be "
            "specified multiple times."
        )
        # Update exception message
        self.args = (message,)
```

**Benefits:**
- Error handlers can catch `OptionError` to handle all option-related errors
- Reduces code duplication
- Clearer conceptual hierarchy

**Drawbacks:**
- More complex inheritance
- Slightly more boilerplate
- Might not add much value if users just catch `ParseError`

---

### 12. Improve Docstring for ParseError Base Class

**Line:** 48-54

**Issue:** `ParseError` has a minimal docstring with no examples or attribute documentation.

**Current:**
```python
class ParseError(AclafError):
    """Base exception for all parsing errors.

    This is the base class for all exceptions raised during command-line
    argument parsing. Applications can catch this exception to handle all
    parsing errors uniformly.
    """
```

**Suggestion:** Enhance with examples and usage guidance:

```python
class ParseError(AclafError):
    """Base exception for all parsing errors.

    This is the base class for all exceptions raised during command-line
    argument parsing. Applications can catch this exception to handle all
    parsing errors uniformly.

    When Raised:
        - Never raised directly; only subclasses are raised
        - Catch this to handle all parsing errors uniformly
        - Raised during argument parsing, not during specification creation

    Example:
        >>> from aclaf.parser import Parser, CommandSpec
        >>> from aclaf.parser.exceptions import ParseError
        >>>
        >>> spec = CommandSpec(name="myapp")
        >>> parser = Parser(spec)
        >>>
        >>> try:
        ...     result = parser.parse(["--unknown-option"])
        ... except ParseError as e:
        ...     print(f"Parsing failed: {e}")
        ...     # Handle error gracefully
        Parsing failed: Unknown option '--unknown-option'

    Note:
        For specification validation errors (which occur during development),
        see SpecValidationError. ParseError only covers runtime parsing errors
        from user-provided input.
    """
```

---

### 13. Consider Adding Suggestions to More Error Messages

**Line:** 615-633

**Observation:** `UnknownSubcommandError` uses `difflib.get_close_matches()` to provide helpful suggestions (line 619), but `UnknownOptionError` doesn't.

**Current UnknownOptionError (line 138):**
```python
message = f"Unknown option '{name}'."
```

**Suggestion:** Add fuzzy matching for options too:

```python
def __init__(self, name: str, possible_names: tuple[str, ...]) -> None:
    self.name: str = name
    self.all_names: tuple[str, ...] = possible_names

    message_parts = [f"Unknown option '{name}'."]

    # Add suggestions if we find similar names
    from difflib import get_close_matches
    suggestions = get_close_matches(name, possible_names, n=3, cutoff=0.6)
    if suggestions:
        if len(suggestions) == 1:
            message_parts.append(f"Did you mean '{suggestions[0]}'?")
        else:
            suggestion_list = "', '".join(suggestions)
            message_parts.append(f"Did you mean one of: '{suggestion_list}'?")

    message = " ".join(message_parts)
    super().__init__(message)
```

**Benefits:** More helpful error messages for typos like `--verbos` → "Did you mean 'verbose'?"

---

### 14. Inconsistent Terminology: "Positional Argument" vs "Positional Parameter"

**Lines:** 636-675, 678-717

**Issue:** The code uses both "positional argument" and "positional parameter" inconsistently:

- `InsufficientPositionalArgumentsError`: Uses "Positional argument" in message (line 672)
- Class name says "Arguments" but spec uses "Parameter"
- Docstring uses both terms

**Recommendation:** Use "positional parameter" consistently to match the spec terminology (`PositionalSpec`), or use "argument" if that's preferred. Pick one and stick with it.

---

### 15. Consider Adding `__str__` Methods for Custom Formatting

**Observation:** All exceptions rely on the default `__str__` implementation which uses `self.args[0]`. This works fine but could be enhanced for programmatic access.

**Suggestion:** For exceptions with rich data, consider adding `__str__`:

```python
class InvalidFlagValueError(ParseError):
    # ... existing code ...

    def __str__(self) -> str:
        """Return formatted error message."""
        message_name = full_option_name(self.name)
        canonical_name = full_option_name(self.option_spec.name)
        valid_values = sorted(self.true_values | self.false_values)
        return (
            f"Invalid value '{self.value}' for option '{message_name}' "
            f"({canonical_name}). Expected one of: {', '.join(valid_values)}."
        )
```

**Benefit:** The message can be regenerated if attributes change, and it's clearer where the message comes from.

**Drawback:** More code to maintain, and it's unclear if attributes should ever change after construction.

## Positive Observations

1. **Excellent Documentation Quality:** Almost all exceptions have comprehensive docstrings with:
   - Clear descriptions
   - Attributes sections with type information
   - "When Raised" sections explaining triggering conditions
   - Working code examples demonstrating usage
   - This is exemplary and should be maintained as a standard.

2. **Consistent Type Annotations:** All attributes are properly typed using Python 3.12+ syntax (PEP 695). This provides excellent IDE support and type checking.

3. **Thoughtful Exception Hierarchy:** The two-level hierarchy (SpecValidationError vs ParseError) clearly separates development-time errors from runtime parsing errors. This is a good design decision.

4. **Rich Context in Exceptions:** Storing `option_spec`, `candidates`, and other context allows error handlers to implement sophisticated recovery strategies.

5. **User-Friendly Error Messages:** Most messages are clear, actionable, and provide context. The distinction between user-provided names and canonical names (e.g., `-o` vs `--output`) is particularly helpful.

6. **Good Use of TYPE_CHECKING:** The forward reference handling for `OptionSpec` (lines 8-9) avoids circular import issues while maintaining type safety.

7. **Consistent Use of full_option_name():** Most exceptions that format option names use the `full_option_name()` utility, showing good abstraction and DRY principles.

8. **Smart Suggestion System:** `UnknownSubcommandError` using `difflib.get_close_matches()` is a great user experience touch.

## Compliance Check

- [x] Follows project coding standards (no specific CLAUDE.md found, but code follows PEP 8 and modern Python practices)
- [x] Proper error handling (exceptions are well-designed)
- [x] Adequate documentation (exemplary docstrings with examples)
- [⚠] Security best practices (N/A for exception definitions)
- [⚠] Performance considerations (Minor: could cache formatted names, but not significant)
- [x] Test coverage (not reviewed, but exceptions are testable)

## Recommendations

### Priority 1 (Do First)
1. **Fix parameter/attribute name inconsistency** (Issue #1)
   - Rename `all_names` to `possible_names` throughout or vice versa
   - Update docstrings to match

2. **Standardize error message formatting** (Issue #2)
   - Use `full_option_name()` consistently in all option-related exceptions
   - Remove hardcoded `--` prefix in `AmbiguousOptionError`

3. **Add canonical names to all option exceptions** (Issue #3)
   - Update `InsufficientOptionValuesError` message
   - Update `MultiValueOptionEqualsError` signature and message

4. **Store true_values/false_values in InvalidFlagValueError** (Issue #4)
   - Add attributes and update docstring

### Priority 2 (Important for Consistency)
5. **Standardize collection types** (Issue #5)
   - Use `tuple[str, ...]` consistently for name collections

6. **Decide fate of ArityMismatchError** (Issue #6)
   - Either remove, repurpose as base class, or document its role

7. **Fix quoting consistency** (Issue #7)
   - Standardize list formatting in error messages

8. **Improve arity display** (Issue #8)
   - Format arity values in a user-friendly way

### Priority 3 (Polish)
9. **Clarify "name" terminology in docstrings** (Issue #9)
10. **Enhance ParseError docstring** (Issue #12)
11. **Add suggestions to UnknownOptionError** (Issue #13)
12. **Standardize positional terminology** (Issue #14)

## References

### Related Files
- `src/aclaf/parser/_utils.py` - Contains `full_option_name()` utility
- `src/aclaf/parser/types.py` - Defines `Arity` type
- `src/aclaf/exceptions.py` - Defines `AclafError` base class

### Python Documentation
- [PEP 8: Style Guide for Python Code](https://peps.python.org/pep-0008/)
- [Exception Best Practices](https://docs.python.org/3/tutorial/errors.html)
- [Type Hints for Exceptions](https://docs.python.org/3/library/typing.html)

### Design Patterns
- **Exception Hierarchy Design:** Group exceptions by semantic meaning (spec vs parse) rather than technical details
- **Message Construction:** Always provide context (what, where, why, how to fix)
- **Attribute Design:** Store data that error handlers need for recovery, not just for message construction

---

## Final Notes

This exceptions module is well-crafted with excellent documentation and thoughtful design. The issues identified are primarily about consistency and polish rather than fundamental problems. Addressing the critical issues (particularly the parameter naming and message formatting inconsistencies) will significantly improve the API's usability and professional feel.

The code demonstrates strong Python practices and attention to user experience. With the recommended improvements, this will be a model exception system that other projects can learn from.
